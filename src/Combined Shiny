library(shiny)
library(leaflet)
library(sf)
library(dplyr)
library(DT)
library(htmltools)

# Load the data
access_score <- read.csv("access_score.csv")
avail_score <- read.csv("avail_with_score.csv")
planning_area_geojson <- st_read("planning_area.geojson")
# Clean the geometries
planning_area_geojson <- st_make_valid(planning_area_geojson)

# Define UI
ui <- fluidPage(
  titlePanel("Accessibility and Availability Analysis"),
  tabsetPanel(
    tabPanel("Accessibility",
             sidebarLayout(
               sidebarPanel(
                 sliderInput("cbdWeight", "Weightage on CBD", min = 0, max = 1, value = 0, step = 0.1),
                 sliderInput("ionWeight", "Weightage on ION", min = 0, max = 1, value = 0, step = 0.1),
                 sliderInput("sghWeight", "Weightage on SGH", min = 0, max = 1, value = 0, step = 0.1),
                 actionButton("seeAccessMap", "See the Map")
               ),
               mainPanel(
                 leafletOutput("accessMap"),
                 DTOutput("accessTable")  # Move the DT output for the accessibility table here
               )
             )
    ),
    tabPanel("Availability",
             sidebarLayout(
               sidebarPanel(
                 sliderInput('trainWeight', "Weightage on Number of Train Stations", min = 0, max = 1, value = 0.25, step = 0.01),
                 sliderInput('busstopWeight', "Weightage on Number of Bus Stops", min = 0, max = 1, value = 0.25, step = 0.01),
                 sliderInput('busfreqWeight', "Weightage on Average Bus Frequency", min = 0, max = 1, value = 0.25, step = 0.01),
                 sliderInput('busserviceWeight', "Weightage on Number of Bus Services", min = 0, max = 1, value = 0.25, step = 0.01),
                 actionButton("seeAvailMap", "See the Map")
               ),
               mainPanel(
                 leafletOutput("availMap"),
                 DTOutput("availTable")  # Move the output for the Availability DataTable here
               )
             )
    )
  )
)


# Define server logic
server <- function(input, output, session) {
  observeEvent(input$seeAccessMap, {
    total_weight <- input$cbdWeight + input$ionWeight + input$sghWeight
    
    if (total_weight != 1) {
      showNotification(
        paste("Total weightage must sum up to 1. Current total is ", total_weight),
        duration = 5,
        type = "error"
      )
    } else {
      # Calculate the scores
      access_score$score <- with(access_score, input$cbdWeight * cbd_diff_score + input$ionWeight * ion_diff_score + input$sghWeight * sgh_diff_score)
      # Normalize the scores to range from 0 to 1
      access_score$normalized_score <- (access_score$score - min(access_score$score)) / (max(access_score$score) - min(access_score$score))
      
      # Merge the scores with the geojson data
      merged_data <- merge(planning_area_geojson, access_score, by = "planning_area")
      
      # Render the map with Leaflet
      output$accessMap <- renderLeaflet({
        leaflet() %>%
          addProviderTiles("CartoDB.Positron") %>%
          addPolygons(data = merged_data,
                      fillColor = ~colorNumeric("RdYlGn", domain = merged_data$normalized_score)(normalized_score),
                      fillOpacity = 0.7,
                      color = "black",
                      weight = 1,
                      label = ~paste(planning_area, ": ", round(normalized_score, 2)),
                      labelOptions = labelOptions(direction = "auto", permanent = FALSE)) %>%
          addLegend(pal = colorNumeric("RdYlGn", domain = merged_data$normalized_score),
                    values = merged_data$normalized_score,
                    title = "Accessibility Score",
                    position = "bottomright")
      })
      
      # Render the accessibility table
      output$accessTable <- renderDT({
        sorted_access_score <- access_score %>%
          select(planning_area, cbd_diff_score, ion_diff_score, sgh_diff_score, normalized_score) %>%
          mutate(cbd_diff_score = round(cbd_diff_score, 2),
                 ion_diff_score = round(ion_diff_score, 2),
                 sgh_diff_score = round(sgh_diff_score, 2),
                 normalized_score = round(normalized_score, 2)) %>%
          arrange(desc(normalized_score))
        datatable(sorted_access_score, options = list(pageLength = 10))
      }, server = FALSE)
    }
  })
  
  observeEvent(input$seeAvailMap, {
    total_weight <- input$trainWeight + input$busstopWeight + input$busfreqWeight + input$busserviceWeight
    
    if (total_weight != 1) {
      showNotification(
        paste("Total weightage must sum up to 1. Current total is ", total_weight),
        duration = 5,
        type = "error"
      )
    } else {
      # Calculate the scores
      avail_score$score <- with(avail_score, input$trainWeight * num_trainstations_score + input$busstopWeight * num_busstops_score + input$busfreqWeight * avg_bus_freq_score + input$busserviceWeight * num_busservices_score)
      
      # Normalize the scores to range from 0 to 1
      avail_score$normalized_score <- (avail_score$score - min(avail_score$score)) / (max(avail_score$score) - min(avail_score$score))
      
      # Merge the scores with the geojson data
      merged_data <- merge(planning_area_geojson, avail_score, by = "planning_area")
      
      # Render the map with Leaflet
      output$availMap <- renderLeaflet({
        leaflet() %>%
          addProviderTiles("CartoDB.Positron") %>%
          addPolygons(data = merged_data,
                      fillColor = ~colorNumeric("RdYlGn", domain = merged_data$normalized_score)(normalized_score),
                      fillOpacity = 0.7,
                      color = "black",
                      weight = 1,
                      label = ~paste(planning_area, ": ", round(normalized_score, 2)),
                      labelOptions = labelOptions(direction = "auto", permanent = FALSE)) %>%
          addLegend(pal = colorNumeric("RdYlGn", domain = merged_data$normalized_score),
                    values = merged_data$normalized_score,
                    title = "Availability Score",
                    position = "bottomright")
      })
      
      # Render the availability table with normalized scores
      output$availTable <- renderDT({
        sorted_avail_score <- avail_score %>%
          select(-num_busstops_score, -num_trainstations_score, -num_busservices_score,
                 -avg_bus_freq_score, -total_score, -score) %>%
          mutate(normalized_score = round(normalized_score, 2)) %>%
          arrange(desc(normalized_score))
        datatable(sorted_avail_score, options = list(pageLength = 10))
      }, server = FALSE)
    }
  })
}

# Run the application
shinyApp(ui = ui, server = server)

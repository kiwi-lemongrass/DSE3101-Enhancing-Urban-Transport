library(shiny)
library(leaflet)
library(sf)
library(dplyr)
library(DT)
library(htmltools)

# Load the data
access_score <- read.csv("access_score.csv")
avail_score <- read.csv("avail_with_score.csv")
planning_area_geojson <- st_read("planning_area.geojson")
# Clean the geometries
planning_area_geojson <- st_make_valid(planning_area_geojson)

# Define UI
ui <- fluidPage(
  titlePanel("Accessibility and Availability Analysis"),
  tabsetPanel(
    tabPanel("Accessibility",
             sidebarLayout(
               sidebarPanel(
                 sliderInput("cbdPoints", "Weightage on CBD", min = 0, max = 1, value = 0, step = 0.05),
                 sliderInput("ionPoints", "Weightage on ION", min = 0, max = 1, value = 0, step = 0.05),
                 sliderInput("sghPoints", "Weightage on SGH", min = 0, max = 1, value = 0, step = 0.05),
                 actionButton("seeAccessMap", "See the Map")
               ),
               mainPanel(
                 leafletOutput("accessMap")
               )
             )
    ),
    tabPanel("Accessibility Table View",
             DTOutput("accessTable")  # Add a DT output for the accessibility table
    ),
    tabPanel("Availability",
             sidebarLayout(
               sidebarPanel(
                 sliderInput('train_w', "Weightage on Number of Train Stations", min = 0, max = 1, value = 0.25, step = 0.05),
                 sliderInput('busstop_w', "Weightage on Number of Bus Stops", min = 0, max = 1, value = 0.25, step = 0.05),
                 sliderInput('busfreq_w', "Weightage on Average Bus Frequency", min = 0, max = 1, value = 0.25, step = 0.05),
                 sliderInput('busservice_w', "Weightage on Number of Bus Services", min = 0, max = 1, value = 0.25, step = 0.05),
                 actionButton("seeAvailMap", "See the Map")
               ),
               mainPanel(
                 leafletOutput("availMap")
               )
             )
    ),
    tabPanel("Availability Table View",
             DTOutput("availTable")  # Output for the Availability DataTable
    )
  )
)

# Define server logic
server <- function(input, output, session) {
  observeEvent(input$seeAccessMap, {
    total_points <- input$cbdPoints + input$ionPoints + input$sghPoints
    
    if (total_points != 1) {
      showNotification(
        paste("Total weightage must sum up to 1. Current total is ", total_points),
        duration = 5,
        type = "error"
      )
    } else {
      # Calculate the scores
      access_score$score <- with(access_score, input$cbdPoints * cbd_diff_score + input$ionPoints * ion_diff_score + input$sghPoints * sgh_diff_score)
      # Normalize the scores to range from 0 to 1
      access_score$normalized_score <- (access_score$score - min(access_score$score)) / (max(access_score$score) - min(access_score$score))
      
      # Merge the scores with the geojson data
      merged_data <- merge(planning_area_geojson, access_score, by = "planning_area")
      
      # Render the map with Leaflet
      output$accessMap <- renderLeaflet({
        leaflet() %>%
          addProviderTiles("CartoDB.Positron") %>%
          addPolygons(data = merged_data,
                      fillColor = ~colorNumeric("RdYlGn", domain = merged_data$normalized_score)(normalized_score),
                      fillOpacity = 0.7,
                      color = "black",
                      weight = 1,
                      label = ~paste(planning_area, ": ", round(normalized_score, 2)),
                      labelOptions = labelOptions(direction = "auto", permanent = FALSE)) %>%
          addLegend(pal = colorNumeric("RdYlGn", domain = merged_data$normalized_score),
                    values = merged_data$normalized_score,
                    title = "Accessibility Score",
                    position = "bottomright")
      })
      
      # Render the accessibility table
      output$accessTable <- renderDT({
        sorted_access_score <- access_score %>%
          select(planning_area, cbd_diff_score, ion_diff_score, sgh_diff_score, normalized_score) %>%
          mutate(cbd_diff_score = round(cbd_diff_score, 2),
                 ion_diff_score = round(ion_diff_score, 2),
                 sgh_diff_score = round(sgh_diff_score, 2),
                 normalized_score = round(normalized_score, 2)) %>%
          arrange(desc(normalized_score))
        datatable(sorted_access_score, options = list(pageLength = 10))
      }, server = FALSE)
    }
  })
  
  observeEvent(input$seeAvailMap, {
    total_points <- input$train_w + input$busstop_w + input$busfreq_w + input$busservice_w
    
    if (total_points != 1) {
      showNotification(
        paste("Total weightage must sum up to 1. Current total is ", total_points),
        duration = 5,
        type = "error"
      )
    } else {
      # Calculate the scores
      avail_score$score <- with(avail_score, round(input$train_w * num_trainstations_score + input$busstop_w * num_busstops_score + input$busfreq_w * avg_bus_freq_score + input$busservice_w * num_busservices_score, 2))
      
      # Merge the scores with the geojson data
      merged_data <- merge(planning_area_geojson, avail_score, by = "planning_area")
      
      # Render the map with Leaflet
      output$availMap <- renderLeaflet({
        leaflet() %>%
          addProviderTiles("CartoDB.Positron") %>%
          addPolygons(data = merged_data,
                      fillColor = ~colorNumeric("RdYlGn", domain = merged_data$score)(score),
                      fillOpacity = 0.7,
                      color = "black",
                      weight = 1,
                      label = ~paste(planning_area, ": ", score),
                      labelOptions = labelOptions(direction = "auto", permanent = FALSE)) %>%
          addLegend(pal = colorNumeric("RdYlGn", domain = merged_data$score),
                    values = merged_data$score,
                    title = "Availability Score",
                    position = "bottomright")
      })
      
      # Render the availability table
      output$availTable <- renderDT({
        sorted_avail_score <- avail_score %>%
          select(-num_busstops_score, -num_trainstations_score, -num_busservices_score, -avg_bus_freq_score, -total_score) %>%
          arrange(desc(score))
        datatable(sorted_avail_score, options = list(pageLength = 10))
      }, server = FALSE)
    }
  })
}

# Run the application
shinyApp(ui = ui, server = server)
